using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DragMove : MonoBehaviour {
	[Header("Setting")]
	public GameObject groundObject;
	protected bool mDidMove = false;
	protected bool mStarted = false;		

	protected Vector3 mLastMovePos;

	protected int groundCollisionLayer;
	
	// Callback
	public delegate void PositionChangeCallback(float x, float y);

	public PositionChangeCallback onPositionChange = null;


	/// <summary>
	/// Start is called on the frame when a script is enabled just before
	/// any of the Update methods is called the first time.
	/// </summary>
	void Start()
	{
		if(groundObject == null) {
			Debug.LogError("DragMove: groundObject is null");	
		} else {
			groundCollisionLayer = groundObject.layer;
		}
	}

	/// <summary>
	/// Reset is called when the user hits the Reset button in the Inspector's
	/// context menu or when adding the component the first time.
	/// </summary>
	public void Reset()
	{
		mDidMove = false;
	}
	
	// Update is called once per frame
	void Update () {

		if(Input.GetMouseButtonDown(0)) {
			mStarted = CheckForStart();
		}else if(Input.GetMouseButtonUp(0)) {
			mStarted = false;
		}

		if(mStarted) {
			if(Input.GetMouseButton(0)) {
				transform.position = PositionAtGround();
			}	
		}
	}

	bool CheckForStart() {
		Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
		RaycastHit hit;

		// ken: next 2 lines is used to 
		Vector3 startPos = ray.GetPoint(0);
		Debug.DrawRay(startPos, ray.direction * 1000, Color.green, 0.5f);
			
		bool isHit = Physics.Raycast(ray, out hit);
		
		
		return isHit && hit.transform == transform;		// rayCast hit on on the current object
		
	}

	Vector3 PositionAtGround() {
		Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
		RaycastHit hit;

		int collisionLayer = 1 << groundCollisionLayer;		// 9=Ground

		//we'll try to hit one of the plane collider gameobjects that were generated by the plugin
		//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
		bool isHit = Physics.Raycast (ray, out hit, Mathf.Infinity, collisionLayer);
		//bool isHit = Physics.Raycast(ray, out hit);
		if(isHit == false) {
			return transform.position;
		}
	
		return hit.point;
	}

}
